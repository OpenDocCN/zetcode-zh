# MySQL 表达式

> [http://zetcode.com/databases/mysqltutorial/expressions/](http://zetcode.com/databases/mysqltutorial/expressions/)

在 MySQL 教程的这一部分中，我们将介绍表达式。

编程语言中的表达式是值，变量，运算符和函数的组合，这些值，变量，运算符和函数根据特定的优先级规则和特定编程语言的关联规则进行解释（求值），然后计算并生成（返回） 有状态的环境）的另一个值。 据说该表达式可以计算出该值。 （维基百科）

## 字面值

字面值是某种常量。 字面值可以是字符串，数字，十六进制值，布尔值和`NULL`。

```sql
mysql> SELECT 3, 'Wolf', 34.5, 0x34, 0+b'10111';
+---+------+------+------+------------+
| 3 | Wolf | 34.5 | 0x34 | 0+b'10111' |
+---+------+------+------+------------+
| 3 | Wolf | 34.5 | 4    |         23 |
+---+------+------+------+------------+

```

在这里，我们返回五个字面值。 即整数，字符串浮点数，十六进制数和二进制值。 十六进制值的前面是`0x`，这是编程语言中的标准。 二进制值前面带有`b`字符，并用单引号引起来。 为了显示可打印的值，我们在二进制符号上添加零。

```sql
mysql> SELECT NULL, \N;
+------+------+
| NULL | NULL |
+------+------+
| NULL | NULL |
+------+------+

```

这是`NULL`值。 这是没有值的。 `NULL`的同义词是`\N`。

```sql
mysql> SELECT TRUE, FALSE;
+------+-------+
| TRUE | FALSE |
+------+-------+
|    1 |     0 |
+------+-------+

```

MySQL 还可以识别布尔值`TRUE`和`FALSE`。 它们可以用大写字母书写。

```sql
mysql> SELECT '2011-01-11', '23:33:01', '98/11/31/ 14:22:20';
+------------+----------+--------------------+
| 2011-01-11 | 23:33:01 | 98/11/31/ 14:22:20 |
+------------+----------+--------------------+
| 2011-01-11 | 23:33:01 | 98/11/31/ 14:22:20 |
+------------+----------+--------------------+

```

MySQL 数据库支持各种日期和时间字面值。

## 变量

变量是与值关联的符号名称。 该值可能会随着时间而改变。 MySQL 中的变量以`@`字符开头。

```sql
mysql> SET @name = 'Jane';

mysql> SELECT @name;
+-------+
| @name |
+-------+
| Jane  |
+-------+

```

我们设置一个变量，然后显示其内容。

## 运算符

运算符用于构建表达式。 SQL 运算符与数学运算符非常相似。 有两种运算符。 二元和一元。 二元运算符使用两个操作数，一元运算符使用一个。 一个运算符可以有一个或两个操作数。 操作数是运算符的输入（参数）之一。

我们有几种类型的运算符：

*   算术运算符
*   布尔运算符
*   关系运算符
*   按位运算符
*   其他运算符

### 一元运算符

我们将展示一些一元运算符。

```sql
mysql> SELECT +3, 3;
+---+---+
| 3 | 3 |
+---+---+
| 3 | 3 |
+---+---+

```

`+`是无操作的。 它什么也没做。

```sql
mysql> SELECT -(3-44);
+---------+
| -(3-44) |
+---------+
|      41 |
+---------+

```

-一元运算符将正值更改为负值，反之亦然。

```sql
mysql> SELECT NOT (3>9);
+-----------+
| NOT (3>9) |
+-----------+
|         1 |
+-----------+

```

`NOT`运算符取反一个值。 `3>9`比较的结果为`false`，而否定运算符将其取为`true`。

### 算术运算符

常见的算术运算符是：乘法，除法，整数除法，加法，减法和模。

```sql
mysql> SELECT 3 + 4 - 5;
+-----------+
| 3 + 4 - 5 |
+-----------+
|         2 |
+-----------+

```

加减法运算符。

```sql
mysql> SELECT 3*3/9;
+--------+
| 3*3/9  |
+--------+
| 1.0000 |
+--------+

```

这些是我们从数学上知道的乘法和除法运算符。

```sql
mysql> SELECT 9/2, 9 DIV 2;
+--------+---------+
| 9/2    | 9 DIV 2 |
+--------+---------+
| 4.5000 |       4 |
+--------+---------+

```

上面的 SQL 语句显示了除法运算符和整数除法运算符之间的区别。 第一个返回浮点数，第二个返回整数。

```sql
mysql> SELECT 11 % 3;
+--------+
| 11 % 3 |
+--------+
|      2 |
+--------+

```

`%`运算符称为模运算符。 它找到一个数除以另一个的余数。 `11 % 3`的 11 模 3 为 2，因为 3 乘以 3 变成 11，余数为 2。

### 逻辑运算符

使用逻辑运算符，我们执行布尔运算。 MySQL 理解以下逻辑运算符：`AND`，`OR`和`NOT`和`XOR`。 逻辑运算符返回`TRUE`或`FALSE`。 在 MySQL 中，1 为`true`，0 为`false`。

如果两个操作数均为`true`，则`AND`运算符的计算结果为`true`。

```sql
mysql> SELECT FALSE AND FALSE, FALSE AND TRUE,
    -> TRUE AND FALSE, TRUE AND TRUE;
+-----------------+----------------+----------------+---------------+
| FALSE AND FALSE | FALSE AND TRUE | TRUE AND FALSE | TRUE AND TRUE |
+-----------------+----------------+----------------+---------------+
|               0 |              0 |              0 |             1 |
+-----------------+----------------+----------------+---------------+

```

前三个操作求值为`false`，最后一个求值为`true`。

```sql
mysql> SELECT 3=3 AND 4=4;
+-------------+
| 3=3 AND 4=4 |
+-------------+
|           1 |
+-------------+

```

两个操作数都为`true`，因此结果为`true`（1）。

如果至少一个操作数为`true`，则`OR`运算符的计算结果为`true`。

```sql
mysql> SELECT FALSE OR FALSE, FALSE OR TRUE, 
    -> TRUE OR FALSE, TRUE OR TRUE;
+----------------+---------------+---------------+--------------+
| FALSE OR FALSE | FALSE OR TRUE | TRUE OR FALSE | TRUE OR TRUE |
+----------------+---------------+---------------+--------------+
|              0 |             1 |             1 |            1 |
+----------------+---------------+---------------+--------------+

```

第一个操作求值为 false，其他操作求值为 true。

如果恰好其中一个操作数为 true，则`XOR`运算符的计算结果为 true。

```sql
mysql> SELECT FALSE XOR FALSE, FALSE XOR TRUE,
    -> TRUE XOR FALSE, TRUE XOR TRUE;
+-----------------+----------------+----------------+---------------+
| FALSE XOR FALSE | FALSE XOR TRUE | TRUE XOR FALSE | TRUE XOR TRUE |
+-----------------+----------------+----------------+---------------+
|               0 |              1 |              1 |             0 |
+-----------------+----------------+----------------+---------------+

```

其中两个操作为`true`。

`NOT`运算符是反运算符。 它使真假成为假。

```sql
mysql> SELECT NOT TRUE, NOT FALSE;
+----------+-----------+
| NOT TRUE | NOT FALSE |
+----------+-----------+
|        0 |         1 |
+----------+-----------+

mysql> SELECT NOT (3=3);
+-----------+
| NOT (3=3) |
+-----------+
|         0 |
+-----------+

```

### 关系运算符

关系运算符用于比较值。 这些运算符总是产生布尔值。

```sql
mysql> SELECT 3*3=9, 9=9;
+-------+-----+
| 3*3=9 | 9=9 |
+-------+-----+
|     1 |   1 |
+-------+-----+

```

=是相等运算符。

```sql
mysql> SELECT 3 < 4, 3 <> 5, 4 <= 4, 5 != 5;
+-------+--------+--------+--------+
| 3 < 4 | 3 <> 5 | 4 <= 4 | 5 != 5 |
+-------+--------+--------+--------+
|     1 |      1 |      1 |      0 |
+-------+--------+--------+--------+

```

关系运算符的用法从数学上是已知的。

### 按位运算符

小数对人类是自然的。 二进制数是计算机固有的。 二进制，八进制，十进制或十六进制符号仅是相同数字的符号。 按位运算符使用二进制数的位。 我们有二进制逻辑运算符和移位运算符。

按位，运算符在两个数字之间进行逐位比较。 仅当操作数中的两个对应位均为 1 时，位位置的结果才为 1。

```sql

    00110
  & 00011
  = 00010

```

第一个数字是二进制符号 6，第二个数字是 3，结果是 2。

```sql
mysql> SELECT 6 & 3, 3 & 6;
+-------+-------+
| 6 & 3 | 3 & 6 |
+-------+-------+
|     2 |     2 |
+-------+-------+

```

按位或运算符在两个数字之间进行逐位比较。 如果操作数中的任何对应位为 1，则位位置的结果为 1。

```sql

     00110
  |  00011
   = 00111

```

结果为`00110`或十进制 7。

```sql
mysql> SELECT 6 | 3, 3 | 6;
+-------+-------+
| 6 | 3 | 3 | 6 |
+-------+-------+
|     7 |     7 |
+-------+-------+

```

按位移位运算符向右或向左移位。

```sql
number << n : multiply number 2 to the nth power
number >> n : divide number by 2 to the nth power

```

这些运算符也称为算术移位。

```sql
     00110
 >>  00001
   = 00011

```

我们将数字 6 的每个位向右移动。 等于将 6 除以 2。结果为`00011`或十进制 3。

```sql
mysql> SELECT 6 >> 1;
+--------+
| 6 >> 1 |
+--------+
|      3 |
+--------+

```

```sql
     00110
  << 00001
   = 01100

```

我们将数字 6 的每个位向左移动。 等于将数字 6 乘以 2。结果为`01100`或十进制 12。

```sql
mysql> SELECT 6 << 1;
+--------+
| 6 << 1 |
+--------+
|     12 |
+--------+

```

### 其他运算符

还剩下一些其他运算符。 这些包括`IS`，`IN`，`LIKE`，`REGEXP`，`BETWEEN`。

`IS`运算符测试操作数是否为布尔值。

```sql
mysql> SET @running = FALSE;
mysql> SELECT @running IS FALSE;
+-------------------+
| @running IS FALSE |
+-------------------+
|                 1 |
+-------------------+

```

我们将变量设置为布尔值`false`。 我们使用`IS`运算符检查变量是否为`FALSE`。

在两种情况下，我们可以使用`IN`运算符。

```sql
mysql> SELECT 'Tom' IN ('Tom', 'Frank', 'Jane');
+-----------------------------------+
| 'Tom' IN ('Tom', 'Frank', 'Jane') |
+-----------------------------------+
|                                 1 |
+-----------------------------------+

```

在这里，我们检查`IN`运算符之后的字符串值'Tom'是否在名称列表中。 返回值是布尔值。

对于以下示例，我们概括了`Cars`表中的内容。

```sql
mysql> SELECT * FROM Cars;
+----+------------+--------+
| Id | Name       | Cost   |
+----+------------+--------+
|  1 | Audi       |  52642 |
|  2 | Mercedes   |  57127 |
|  3 | Skoda      |   9000 |
|  4 | Volvo      |  29000 |
|  5 | Bentley    | 350000 |
|  6 | Citroen    |  21000 |
|  7 | Hummer     |  41400 |
|  8 | Volkswagen |  21600 |
+----+------------+--------+

```

在第二种情况下，`IN`运算符允许您在`WHERE`子句中指定多个值。

```sql
mysql> SELECT * FROM Cars Where Name IN ('Audi', 'Hummer');
+----+--------+-------+
| Id | Name   | Cost  |
+----+--------+-------+
|  1 | Audi   | 52642 |
|  7 | Hummer | 41400 |
+----+--------+-------+

```

从`Cars`表中，我们选择在`IN`运算符之后列出的汽车。

`WHERE`子句中使用`LIKE`运算符在列中搜索指定的模式。

```sql
mysql> SELECT * FROM Cars WHERE Name LIKE 'Vol%';
+----+------------+-------+
| Id | Name       | Cost  |
+----+------------+-------+
|  4 | Volvo      | 29000 |
|  8 | Volkswagen | 21600 |
+----+------------+-------+

```

在这里，我们选择名称以`"Vol"`开头的汽车。

```sql
mysql> SELECT * FROM Cars WHERE Name LIKE '____';
+----+------+-------+
| Id | Name | Cost  |
+----+------+-------+
|  1 | Audi | 52642 |
+----+------+-------+

```

在这里，我们选择正好有四个字符的汽车名称。 有四个下划线。

`LIKE`运算符仅提供简单的模式匹配。 `REGEXP`运算符功能更强大。 它提供与正则表达式匹配的模式。 `RLIKE`是`REGEXP`的同义词。

```sql
mysql> SELECT * FROM Cars WHERE Name REGEXP 'e.$';
+----+------------+--------+
| Id | Name       | Cost   |
+----+------------+--------+
|  2 | Mercedes   |  57127 |
|  5 | Bentley    | 350000 |
|  6 | Citroen    |  21000 |
|  7 | Hummer     |  41400 |
|  8 | Volkswagen |  21600 |
+----+------------+--------+

```

在这里，我们有汽车，它们的最后一个字符是'e'。

```sql
mysql> SELECT * FROM Cars WHERE Name REGEXP '^.e.*e.$';
+----+----------+--------+
| Id | Name     | Cost   |
+----+----------+--------+
|  2 | Mercedes |  57127 |
|  5 | Bentley  | 350000 |
+----+----------+--------+

```

我们选择的汽车中，倒数第二个也是一个字符是`"e"`。

`BETWEEN`运算符等效于一对比较。 `a BETWEEN b AND c`等效于`a>=b AND a<=c`。

```sql
mysql> SELECT * FROM Cars WHERE Cost BETWEEN 20000 AND 55000;
+----+------------+-------+
| Id | Name       | Cost  |
+----+------------+-------+
|  1 | Audi       | 52642 |
|  4 | Volvo      | 29000 |
|  6 | Citroen    | 21000 |
|  7 | Hummer     | 41400 |
|  8 | Volkswagen | 21600 |
+----+------------+-------+

```

在此 SQL 语句中，我们选择了价格在 20000 至 55000 单位之间的汽车。

## 优先顺序

运算符优先级告诉我们首先求值哪个运算符。 优先级对于避免表达式中的歧义是必要的。

以下表达式 28 或 40 的结果是什么？

```sql
3 + 5 * 5

```

像数学中一样，乘法运算符的优先级高于加法运算符。 结果是 28。

```sql
(3 + 5) * 5

```

要更改求值顺序，可以使用方括号。 方括号内的表达式始终首先被求值。

```sql
mysql> SELECT 3+5*5, (3+5)*5;
+-------+---------+
| 3+5*5 | (3+5)*5 |
+-------+---------+
|    28 |      40 |
+-------+---------+

```

第一个表达式的计算结果为 28，因为乘法运算符的优先级高于加法运算符。 在第二个示例中，我们使用方括号更改了优先顺序。 因此第二个表达式的值为 40。

## 关联性

有时，优先级不能令人满意地确定表达式的结果。 还有另一个规则称为关联性。 运算符的关联性确定优先级相同的运算符的求值顺序。

```sql
9 / 3 * 3

```

此表达式的结果是 9 还是 1？ 乘法，删除和模运算符从左到右关联。 因此，该表达式的计算方式为：`(9 / 3) * 3`，结果为 9。

```sql
mysql> SELECT 9 / 3 * 3;
+-----------+
| 9 / 3 * 3 |
+-----------+
|    9.0000 |
+-----------+

```

关联规则是从左到右。

```sql
mysql> SELECT 0 AND 0 OR 1;
+--------------+
| 0 AND 0 OR 1 |
+--------------+
|            1 |

```

关联规则再次从左到右。 如果从右到左，则结果为 0。

算术，布尔，关系和按位运算符都是从左到右关联的。

在 MySQL 教程的这一部分中，我们介绍了 MySQL 表达式。